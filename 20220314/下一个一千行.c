#include <stdio.h>
//void test()
//{
//	printf("hehe");
//}
//int main()
//{
//	test(100);
//	return 0;
//}
//int main()
//{
//	int a = 20;
//	int b = -10;
//	char c = 'a';
//
//	return 0;
//}
//int main()
//{
//	char a = -128;
//	//100000000000000000000000100000000  原码
//	//111111111111111111111111011111111  反码
//	//111111111111111111111111100000000  补码
//	//100000000char类型只有8个比特位  存储的补码
//	printf("%u\n", a);
//	//%d 打印有符号的十进制整数。
//	//%u 打印无符号的十进制整数。
//	//补码 1000000000  
//	//整形提升  000000000000000000000001000000000
//	//反码      000000000000000000000000111111111
//	//原码      111111111111111111111111000000000
//	//所以打印的数字很大。
//	return 0;
//int main()
//{
//	char a = -1;//char会有整形提升和整形截断。
//	//一开始以int类型进行补码运算，最后存储是进行整形截断，即只存储最后8位。最高位仍视为符号位
//	signed char b = -1;//有符号char类型，同上，一般都是有符号类型，通常省略signed。
//	unsigned char c = -1;//无符号char类型，最高位不视为符号位。
//	printf("a = %d,b = %d,c = %d", a, b, c);
//	//此处打印的都是%d类型有符号十进制整数。
//	//在运算时会进行整形提升，即用32位算。
//	//用c举例。
//	//补码 11111111
//	//整形提升，由于为无符号数，前面加零，
//	//000000000000000000000111111111 整形提升后的补码
//	//由于最前面为0，时正数，原反补相同，说以为255.
//	return 0;
//}
//int main()
//{
//	unsigned int i = 0;
//	for(i = 9; i >= 0; i--)//死循环，还是那个⚪。无符号是0 到 2 ^32-1.
//	{
//		printf("%u\n", i);
//	}
//	return 0;
//}
//int main()
//{
//	char arr[1000];
//	int i = 1;
//	for (i = 0; i < 1000; i++)
//	{
//		arr[i] = -1 - i;
//	}
//	printf("%d", strlen(arr));//strlen不算0，在0前面停
//	//一开始是从-1开始算起，到-128，+1到127，再一直减到1，0遇到0停下，且不计算。
//	return 0;
//}
//int main()
//{
//	float f = 6.5;
//	//二进制  110.1(整数部分相同，小数部分，0.5为2的负一次方，所以为0.1
//	//类似0.125为2的负三次方，则为0.001）
//	//整数S = 0；
//	//1《= M 《2  M = 1.101；（M因为开头全为1，故1省略不储存）
//	//向后移了两位，E = 2（E有可能是负数）；
//	//为了不考虑正负，E在存储时，+127
//	// E = 2+127=129
//	// //存储的字节
//	//第一位为S
//	//再八位为E
//	//最后全为M
//	//0  10000001  10100000000000000000
//	//S    E +127    M 去开头1，小数向后补零
//	//0100 0000 1101 0000 0000 0000 0000 0000
//	//转换为16进制
//	//40 d0 00 00
//	//所以存储为0x00 00 d0 40
//	return 0;
//}
int main()
{
	int n = 9;
	float* pFloat = (float*)&n;
	printf("%d\n", n);//9
	printf("%f\n", *pFloat);//0.0000000000000
	//整形强行转换为浮点型，E的那八位很容易全为0，此时为 num * 2^-126 为很小的数，所以为0.0000000000

	*pFloat = 9.0;
	printf("%d", n);//9.0强行存储再整形中，E的部位通常1  0 都有，所以会是很大的数。
	printf("%f", *pFloat);

	return 0;
}
