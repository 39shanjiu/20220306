#include <stdio.h>
//void test()
//{
//	printf("hehe");
//}
//int main()
//{
//	test(100);
//	return 0;
//}
//int main()
//{
//	int a = 20;
//	int b = -10;
//	char c = 'a';
//
//	return 0;
//}
//int main()
//{
//	char a = -128;
//	//100000000000000000000000100000000  原码
//	//111111111111111111111111011111111  反码
//	//111111111111111111111111100000000  补码
//	//100000000char类型只有8个比特位  存储的补码
//	printf("%u\n", a);
//	//%d 打印有符号的十进制整数。
//	//%u 打印无符号的十进制整数。
//	//补码 1000000000  
//	//整形提升  000000000000000000000001000000000
//	//反码      000000000000000000000000111111111
//	//原码      111111111111111111111111000000000
//	//所以打印的数字很大。
//	return 0;
//int main()
//{
//	char a = -1;//char会有整形提升和整形截断。
//	//一开始以int类型进行补码运算，最后存储是进行整形截断，即只存储最后8位。最高位仍视为符号位
//	signed char b = -1;//有符号char类型，同上，一般都是有符号类型，通常省略signed。
//	unsigned char c = -1;//无符号char类型，最高位不视为符号位。
//	printf("a = %d,b = %d,c = %d", a, b, c);
//	//此处打印的都是%d类型有符号十进制整数。
//	//在运算时会进行整形提升，即用32位算。
//	//用c举例。
//	//补码 11111111
//	//整形提升，由于为无符号数，前面加零，
//	//000000000000000000000111111111 整形提升后的补码
//	//由于最前面为0，时正数，原反补相同，说以为255.
//	return 0;
//}
//int main()
//{
//	unsigned int i = 0;
//	for(i = 9; i >= 0; i--)//死循环，还是那个⚪。无符号是0 到 2 ^32-1.
//	{
//		printf("%u\n", i);
//	}
//	return 0;
//}
//int main()
//{
//	char arr[1000];
//	int i = 1;
//	for (i = 0; i < 1000; i++)
//	{
//		arr[i] = -1 - i;
//	}
//	printf("%d", strlen(arr));//strlen不算0，在0前面停
//	//一开始是从-1开始算起，到-128，+1到127，再一直减到1，0遇到0停下，且不计算。
//	return 0;
//}
//int main()
//{
//	float f = 6.5;
//	//二进制  110.1(整数部分相同，小数部分，0.5为2的负一次方，所以为0.1
//	//类似0.125为2的负三次方，则为0.001）
//	//整数S = 0；
//	//1《= M 《2  M = 1.101；（M因为开头全为1，故1省略不储存）
//	//向后移了两位，E = 2（E有可能是负数）；
//	//为了不考虑正负，E在存储时，+127
//	// E = 2+127=129
//	// //存储的字节
//	//第一位为S
//	//再八位为E
//	//最后全为M
//	//0  10000001  10100000000000000000
//	//S    E +127    M 去开头1，小数向后补零
//	//0100 0000 1101 0000 0000 0000 0000 0000
//	//转换为16进制
//	//40 d0 00 00
//	//所以存储为0x00 00 d0 40
//	return 0;
//}
//int main()
//{
//	int n = 9;
//	float* pFloat = (float*)&n;
//	printf("%d\n", n);//9
//	printf("%f\n", *pFloat);//0.0000000000000
//	//整形强行转换为浮点型，E的那八位很容易全为0，此时为 num * 2^-126 为很小的数，所以为0.0000000000
//
//	*pFloat = 9.0;
//	printf("%d", n);//9.0强行存储再整形中，E的部位通常1  0 都有，所以会是很大的数。
//	printf("%f", *pFloat);
//
//	return 0;
//}
//int main()
//{
//    char* p = 'a';
//	//printf("%c\n", *p);
//	//printf("%s\n", p);
//	printf("hello world\n");
//	return 0;
//}

//int main()
//{
//	char arr1[] = "abcdef";
//	char arr2[] = "abcdef";
//	char* p1 = "abcdef";
//	char* p2 = "abcdef";
//	//打印haha，两个arr的首地址不同。
//	if (arr1 == arr2)
//	{
//		printf("hehe\n");
//	}
//	else
//	{
//		printf("haha\n");
//	}
//	//打印hehe，两个指针存的内容相同，为了省内存用同一个内存。
//	if (p1 == p2)
//	{
//		printf("hehe\n");
//	}
//	else
//	{
//		printf("haha\n");
//	}
//	/*char* p = "abcdef";
//	printf("%c\n", *p);
//	printf("%s\n", p);
//	return 0;*/
//}
//int main()
//{
//	int arr1[] = { 1,2,3,4,5 };
//	int arr2[] = { 2,3,4,5,6 };
//	int arr3[] = { 3,4,5,6,7 };
//	int* parr[] = { arr1,arr2,arr3 };
//	int i = 0;
//	int  k = 0;
//	for (i = 0; i < 3; i++)
//	{
//		for (k = 0; k < 5; k++)
//		{
//			printf("%d  ", *(parr[i]+k));
//		}
//		printf("\n");
//	}
//	return 0;
////}
//int main()
//{
//	char* arr1[10] = { 0 };//指针数组，存放指针的数组，是数组。
//	char*(* pa1)[10] = &arr1;//数组的地址
//	//取地址指针数组，（*pa1）相当于创建一个数组指针变量
//	// 这个指针指向10个地址，char*告诉这个数组指针指向的类型
//	//char*与指向的数组类型相同。
//	int arr2[10] = { 0 };
//	int (*pa2)[10] = &arr2;
//	//int类型是与指向的数组相同类型
//	return 0;
//}
//void print1(int arr[3][5], int x, int y)
//{
//	int i = 0;
//	for (i = 0; i < x; i++)
//	{
//		int k = 0;
//		for (k = 0; k < y; k++)
//		{
//			printf("%d ", *(*(arr + i) + k));//
//			//arr+i arr指的是第一行的数组地址
//			// arr[3][5]这里相当于有3个数组元素，每个元素是有5个元素的数组
//			// 所以首元素的地址是第一行的数组元素
//			// *（arr+i）解引用，得到第一行的数组元素的地址（该元素是数组，所以该元素的地址是元素的首元素地址）
//			// 所以解引用后得到的是第一行第一列元素的地址
//			//*(*(arr+i)+k)所以加上k后还需要解引用得到元素
//		}
//		printf("\n");
//	}
//}
//void print2(int (*p)[5], int x, int y)
//{
//	int i = 0;
//	for (i = 0; i < x; i++)
//	{
//		int k = 0;
//		for (k = 0; k < y; k++)
//		{
//			//*p == arr
//			//以下四种效果相同
//			printf("%d ", *(*(p + i) + k));
//			//同上
//			printf("%d ", (*(p + i))[k]);//
//			//为防止*（p+i）与[k]结合，所以要在前面加上括号
//
//			printf("%d ", *(p[i]+k));
//			//p[i]相当与*（p+i）
//			printf("%d ", p[i] [k]);
//		    
//			//对于一维数组来说p[i] == arr[i] == *(p+i) == *(arr+i)
//			
//		}
//		printf("\n");
//	}
//}
//int main()
//{
//	int arr[3][5] = { {1,2,3,4,5},{2,3,4,5,6},{3,4,5,6,7} };
//	print1(arr, 3, 5);
//	print2(arr, 3, 5);
//	return 0;
//}
//int main()
//{
//	int arr[5];
//	//普通数组，有五个元素，每个元素类型是int --- 数组
//	int* parr1[10];
//	//是个指针数组，有10个元素，每个元素类型是int* -- 数组
//	int (*parr2)[10];
//	//数组指针，该指针指向一个数组，该数组有10个元素，元素类型为int ---指针
//	int(*parr3[10])[5];
//	//parr3先与[10]结合，成为数组，再以*结合变成数组指针类似与*arr
//	//数组指针指向一个有5个元素的数组。
//	//有一个数组有10个元素，每个元素是个指针，每个指针都指向有5个元素的数组
//	//数组存指针，指针指向数组。
//	return 0;
//}
//int main()
//{
//	int arr1[5] = { 0 };
//	int *arr2[10] = {0}:
//	return 0;
//}
//int Add(int x, int y)
//{
//	int z = x + y;
//	return z;
//}
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int arr[10] = { 0 };
//	Add(a, b);
//	//取地址函数名与直接函数名效果一样。
//	printf("%p\n", Add);
//	printf("%p\n", &Add);
//	//函数指针，要加括号，与数组相似。
//	//存放函数地址的指针。
//	int (*p)(int, int) = Add;
//	printf("%d\n", (*p)(2, 3));
//	return 0;
//}
//int main()
//{
//	(*(void (*)())0);
//	//不要怕，很简单。
//	//首先从0下手，一个常数前面有括号，说明前面括号内的作用为强制类型转换0的类型。
//	// 0前面的括号为（void （*）（））大括号里面的内容即为函数指针，
//	// 说明0被强制转换为函数指针，该指针地址指向0；
//	// 大括号前面+*-》解引用，表示调用0地址处的函数。
//	void (*signal(int, void(*)(int)))(int);
//	//一个函数指针
//	//中间的函数名用了一个函数表示。
//	//该函数有两个参数，一个是int，另一个是函数指针。
//	return 0;52222222222221656541
//}232333333333333222222222222316465
typedef unsigned int uint;
int main()
{
	int i;
	return 0;
}